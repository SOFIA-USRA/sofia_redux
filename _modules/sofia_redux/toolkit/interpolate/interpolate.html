<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.toolkit.interpolate.interpolate &#8212; sofia_redux v1.3.4.dev38+g92ea2f4</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    
    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../../../_static/documentation_options.js?v=6aa39468"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://irsa.ipac.caltech.edu/Missions/sofia.html"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">sofia_redux v1.3.4.dev38+g92ea2f4</a>
	 &#187;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.toolkit.interpolate.interpolate</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

import itertools
import math
import warnings

from astropy import log
import numba as nb
import numpy as np
from scipy import interpolate
from scipy.ndimage import interpolation
from scipy.spatial.qhull import Delaunay

from sofia_redux.toolkit.utilities.func import nantrim, to_array_shape, stack


__all__ = [&#39;line_shift&#39;, &#39;interpolate_nans&#39;, &#39;spline&#39;, &#39;sincinterp&#39;,
           &#39;interp_1d_point&#39;, &#39;interp_1d_point_with_error&#39;,
           &#39;interp_error_1d&#39;, &#39;interp_error_nd&#39;, &#39;interp_error&#39;,
           &#39;Interpolate&#39;, &#39;tabinv&#39;, &#39;findidx&#39;]


<div class="viewcode-block" id="line_shift">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.line_shift.html#sofia_redux.toolkit.interpolate.interpolate.line_shift">[docs]</a>
def line_shift(y, offset, order=3, missing=np.nan):
    &quot;&quot;&quot;
    Shift an equally spaced array of data values by an offset

    Required because no Python standard interpolation algorithms
    allow for nan values in the input data without slowing down
    the processing by several orders of magnitude.

    Parameters
    ----------
    y : array_like
        equally spaced input data
    offset : offset
        offset to shift_image data.  Units are the input data spacing
    order : int
        values must be 2-5.
        2-5: spline interpolation of the same order
    missing : int or float
        numpy.nan values are treated as missing and will be ignored
        during the fit.  In the output array, any missing values
        will be replaced by `missing`.
    Returns
    -------
    array_like
        numpy.ndarray.  Will be of numpy.float32 if y was int type
    &quot;&quot;&quot;
    intype = type(y[0])
    if order == 0:
        offset = int(offset)
        result = interpolation.shift(np.float64(y), offset,
                                     order=0, cval=missing)
        if not (np.isnan(result).any() and np.issubdtype(intype, np.integer)):
            result = intype(result)
        return result

    mask = ~np.isnan(y)
    weights = np.float64(mask)
    result = np.empty_like(weights)
    result.fill(missing)
    ny = int(weights.sum())
    order = order if order &lt; ny else int(ny - 1)
    if order &lt;= 0:
        return result
    yind = np.arange(len(y))
    tck = interpolate.splrep(yind[mask], y[mask], s=0, k=order)
    xout = yind - offset
    valid = (xout &gt;= min(yind[mask])) &amp; (xout &lt;= max(yind[mask]))
    if ~np.any(valid):
        return result
    yout = interpolate.splev(xout[valid], tck)
    result[yind[valid]] = yout
    if not np.issubdtype(intype, np.integer):
        return intype(result)
    else:
        return np.float32(result)</div>



<div class="viewcode-block" id="interpolate_nans">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.interpolate_nans.html#sofia_redux.toolkit.interpolate.interpolate.interpolate_nans">[docs]</a>
def interpolate_nans(x, y, xout, missing=np.nan, order=3, width=1, tck=False):
    &quot;&quot;&quot;
    Interpolate values containing NaNs

    Parameters
    ----------
    x : np.array
        independent variable
    y : np.array
        dependent variable
    xout : np.array
        output locations
    missing : int or float, optional
        value to fill when a value cannot be determined
    width : spacing between x values.  Used to determine minimum order
    tck : bool, optional
        if True, returns an array containing the vector limits of knots,
        B-spline coefficients, and the degree of the spline.
    order : int
        spline order

    Returns
    -------
    np.array or tuple
        y interpolated onto xout or tck
    &quot;&quot;&quot;

    itype = np.asarray(y).dtype
    if not tck:
        result = np.full((len(xout),), missing, dtype=itype)
    else:
        result = [], [], []
    if order &lt; 1 or order &gt; 5:
        log.error(&quot;order must be between 1 and 5&quot;)
        return result

    mask = ~np.isnan(y)
    nvalid = mask.sum()
    if not np.any(mask):
        return result

    order = order if order &lt; nvalid else nvalid - 1
    if order &lt;= 0:
        return result

    idxvalid = np.arange(len(y))[mask]
    xvalid = x[idxvalid]
    yvalid = y[idxvalid]
    sortidx = np.array(
        [x for _, x in sorted(zip(xvalid, np.arange(nvalid)))])
    sortx = xvalid[sortidx]

    lower = np.array(list(
        map(lambda z: ((xvalid &lt; z) &amp; (xvalid &gt;= z - order * width)).sum(),
            sortx)))
    upper = np.array(list(
        map(lambda z: ((xvalid &gt; z) &amp; (xvalid &lt;= z + order * width)).sum(),
            sortx)))

    # we do not want to fit areas that are not bounded by valid data
    # so define regions that can be fitted successfully using a determined
    # order.  single values will just have to be plonked into a cell
    singles = np.where((lower == 0) &amp; (upper == 0))[0]
    for loner in singles:
        lidx = sortidx[loner]
        if not tck:
            result[idxvalid[lidx]] = yvalid[lidx]
        else:
            result[0].append(xvalid[lidx])
            result[1].append(yvalid[lidx])

    if len(lower) &lt;= 1 or len(upper) &lt;= 1:  # pragma: no cover
        return result

    starts = (lower == 0) &amp; (upper != 0)
    starts[:-1][starts[:-1] &amp; starts[1:]] = False
    stops = (lower != 0) &amp; (upper == 0)
    stops[1:][stops[1:] &amp; stops[:-1]] = False
    box_lower = np.where(starts)[0]
    box_upper = np.where(stops)[0]

    for bl in box_lower:
        bu = box_upper[box_upper &gt; bl].min()
        inds = sortidx[bl: bu + 1]
        outidx = (xout &gt;= xvalid[inds].min()) &amp; (xout &lt;= xvalid[inds].max())
        if not np.any(outidx):
            continue
        fx = xvalid[inds]
        fy = yvalid[inds]
        fidx = fx.argsort()
        fx = fx[fidx]
        fy = fy[fidx]
        maxorder = (lower[bl: bu + 1] + upper[bl: bu + 1]).max()
        maxorder = order if maxorder &gt; order else maxorder
        box_tck = interpolate.splrep(fx, fy, k=maxorder, s=0)

        if tck:
            result[0].extend(box_tck[0])
            result[1].extend(box_tck[1])
            result[2].append(box_tck[2])
        else:
            result[outidx] = interpolate.splev(xout[outidx], box_tck)

    return result</div>



<div class="viewcode-block" id="spline">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.spline.html#sofia_redux.toolkit.interpolate.interpolate.spline">[docs]</a>
def spline(x, y, xout, sigma=1.0):
    &quot;&quot;&quot;
    Perform cubic spline (tensioned) interpolation

    Replicates IDL spline function.  There are no standard Python
    Libraries that do this.  This function fits the input points
    exactly allowing flexibility between the points where the
    &quot;tension&quot; of the fit is determined by sigma.

    Parameters
    ----------
    x : array_like of float (N,)
        Independent values.  Values MUST be monotonically increasing
    y : array_like of float (N,)
        Dependent values.
    xout : float or array_like of float (M,)
        New Independent values
    sigma : float, optional
        The amount of &quot;tension&quot; that is applied to the curve.  The
        default value is 1.0.  If sigma is close to 0, (e.g., 0.01),
        then effectively there is a cubic spline fit.  If sigma is
        large, (e.g., greater than 10), then the fit will be like a
        polynomial interpolation

    Returns
    -------
    yout : float or numpy.ndarray of float (M,)
        `y` interpolated at `xout`.

    Notes
    -----
    Author:	Walter W. Jones, Naval Research Laboratory, Sept 26, 1976.
    Reviewer: Sidney Prahl, Texas Instruments.
    Adapted for IDL: DMS, March, 1983.
    CT, RSI, July 2003: Added double precision support and DOUBLE keyword,
    use vector math to speed up the loops.
    CT, RSI, August 2003: Must have at least 3 points.
    Adapted for Python: Dan Perera (USRA), April, 2019
    &quot;&quot;&quot;
    if sigma &lt; 0.001:
        sigma = 0.001
    x, y = np.array(x).astype(float), np.array(y).astype(float)
    n = x.size
    if x.ndim != 1:
        raise ValueError(&quot;x array must have 1 dimension&quot;)
    elif y.ndim != 1:
        raise ValueError(&quot;y array must have 1 dimension&quot;)
    elif n &lt; 3:
        raise ValueError(&quot;require at least 3 elements in x and y&quot;)
    elif y.size != n:
        raise ValueError(&quot;x and y shape mismatch&quot;)

    isarr = hasattr(xout, &#39;__len__&#39;)
    if not isarr:
        xout = [xout]
    xout = np.array(xout).astype(float)
    if xout.ndim != 1:
        raise ValueError(&quot;xout must have 1 dimension&quot;)

    yp = np.zeros(2 * n)  # storage

    delx1 = x[1] - x[0]
    right = delx1 &lt; 0
    dx1 = (y[1] - y[0]) / delx1
    delx2 = x[2] - x[1]
    delx12 = x[2] - x[0]

    c1 = -(delx12 + delx1) / delx12 / delx1
    c2 = delx12 / delx1 / delx2
    c3 = -delx1 / delx12 / delx2

    nm1 = n - 1

    slpp1 = c1 * y[0] + c2 * y[1] + c3 * y[2]
    deln = x[nm1] - x[nm1 - 1]
    delnm1 = x[nm1 - 1] - x[nm1 - 2]
    delnn = x[nm1] - x[nm1 - 2]
    c1 = (delnn + deln) / delnn / deln
    c2 = -delnn / deln / delnm1
    c3 = deln / delnn / delnm1
    slppn = c3 * y[nm1 - 2] + c2 * y[nm1 - 1] + c1 * y[nm1]

    sigmap = sigma * nm1 / (x[nm1] - x[0])
    dels = sigmap * delx1
    exps = np.exp(dels)
    sinhs = 0.5 * (exps - (1.0 / exps))
    sinhin = 1.0 / (delx1 * sinhs)
    diag1 = sinhin * (dels * 0.5 * (exps + (1.0 / exps)) - sinhs)
    diagin = 1.0 / diag1
    yp[0] = diagin * (dx1 - slpp1)
    spdiag = sinhin * (sinhs - dels)
    yp[n] = diagin * spdiag

    delx2 = np.diff(x)  # x[1:] - x[:-1]
    dx2 = np.diff(y) / delx2  # (y[1:] - y[:-1]) / delx2
    dels = sigmap * delx2
    exps = np.exp(dels)
    sinhs = 0.5 * (exps - (1.0 / exps))
    sinhin = 1.0 / (delx2 * sinhs)
    diag2 = sinhin * (dels * (0.5 * (exps + (1.0 / exps))) - sinhs)
    diag2[1:] += diag2[:-1]
    diag2[0] = 0
    dx2nm1 = dx2[nm1 - 1]  # need to save this to calculate yp[nm1]
    dx2[1:] -= dx2[:-1]
    dx2[0] = 0
    spdiag = sinhin * (sinhs - dels)

    # Need to do an iterative loop for this part
    for i in range(1, nm1):
        diagin = 1.0 / (diag2[i] - spdiag[i - 1] * yp[i + n - 1])
        yp[i] = diagin * (dx2[i] - spdiag[i - 1] * yp[i - 1])
        yp[i + n] = diagin * spdiag[i]

    diagin = 1.0 / (diag1 - spdiag[nm1 - 1] * yp[n + nm1 - 1])
    yp[nm1] = diagin * (slppn - dx2nm1 - spdiag[nm1 - 1] * yp[nm1 - 1])
    for i in range(n - 2, -1, -1):
        yp[i] -= yp[i + n] * yp[i + 1]

    # find subscript where x[subs] &gt; xout(j) &gt; xx[subs-1]
    subs1 = np.digitize(xout, x[1:nm1], right=right)
    subs = subs1 + 1

    s = x[nm1] - x[0]
    sigmap = sigma * nm1 / s
    del1 = xout - x[subs1]
    del2 = x[subs] - xout
    dels = x[subs] - x[subs1]
    exps1 = np.exp(sigmap * del1)
    sinhd1 = 0.5 * (exps1 - (1.0 / exps1))
    exps = np.exp(sigmap * del2)
    sinhd2 = 0.5 * (exps - (1.0 / exps))
    exps *= exps1
    sinhs = 0.5 * (exps - (1.0 / exps))
    spl = (yp[subs] * sinhd1 + yp[subs1] * sinhd2) / sinhs
    spl += ((y[subs] - yp[subs]) * del1 + (y[subs1] - yp[subs1]) * del2) / dels

    return spl if isarr else spl[0]</div>



<div class="viewcode-block" id="sincinterp">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.sincinterp.html#sofia_redux.toolkit.interpolate.interpolate.sincinterp">[docs]</a>
def sincinterp(x, y, xout, dampfac=3.25, ksize=21,
               skipsort=False, cval=np.nan):
    &quot;&quot;&quot;
    Perform a sinc interpolation on a data set

    Parameters
    ----------
    x : array_like of (int or float)
        (shape1,) The independent values of the data
    y : array_like of (int or float)
        (shape1,) The dependent values of the data
    xout : array_like of (int or float) or (int or float)
        (shape2,) The new independent values of the data
    dampfac : int or float, optional
        damping factor for sinc interpolation
    ksize : float or int, optional
        Kernel size used for interpolation.  This should be a positive
        odd integer.  If an even value is passed, then the kernel size
        will be increased by one.  Float values will be floored.
    skipsort : bool, optional
        By default, x and y data are sorted by the x value.  This can
        be a fairly intensive operation, so if you know the data is
        already sorted, then set `skipsort` to skip sorting.  Note, this
        is dangerous as no error will be reported.  Be sure you have
        a sorted `x` before attempting.
    cval: float, optional
        Value to fill in requested interpolation points outside the
        data range.

    Returns
    -------
    numpy.ndarray of float
        (shape2,) The new dependent values of the data
    &quot;&quot;&quot;
    ksize = int(ksize)
    if ksize % 2 == 0:
        ksize += 1
    if ksize &lt; 1:
        raise ValueError(&quot;ksize must be a positive (odd) integer&quot;)

    x = np.array(x).astype(float)
    y = np.array(y).astype(float)
    if x.shape != y.shape:
        raise ValueError(&quot;x and y array shape mismatch&quot;)

    isarr = hasattr(xout, &#39;__len__&#39;)
    if not isarr:
        xout = [xout]
    xout = np.array(xout).astype(float)

    mask = np.isfinite(x) &amp; np.isfinite(y)
    yout = np.full(xout.shape, cval)
    if mask.sum() &lt; 2:  # cannot interpolate
        return yout

    x, y = x[mask], y[mask]
    if not skipsort:
        xsort = np.argsort(x)
        x, y = x[xsort], y[xsort]
    xx = tabinv(x, xout)
    ix = xx.astype(int)

    # Values directly on points
    fx = xx - ix
    onpoint = fx == 0
    if onpoint.any():
        yout[onpoint] = np.take(y, ix[onpoint])

    # use sinc interpolation for the points having fractional values
    if not onpoint.all():
        dx = fx[~onpoint]
        kernel = np.arange(ksize) - (ksize // 2)
        kx = np.resize(kernel, (dx.size, kernel.size)).T
        lobe = kx.copy()
        kx = kx - dx
        sinc = np.exp(-(kx / dampfac) ** 2) * np.sinc(kx)
        lobe = np.clip(lobe + ix[~onpoint], 0, x.size - 1)
        vals = np.take(y, lobe)
        yout[~onpoint] = np.sum(sinc * vals, axis=0)

    if not isarr:
        yout = yout[0]

    return yout</div>



<div class="viewcode-block" id="interp_1d_point">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.interp_1d_point.html#sofia_redux.toolkit.interpolate.interpolate.interp_1d_point">[docs]</a>
@nb.njit(cache=True, nogil=False, parallel=False, fastmath=False)
def interp_1d_point(x, y, xout):  # pragma: no cover
    &quot;&quot;&quot;
    Perform linear interpolation at a single point. `x` must be monotonically
    increasing or decreasing containing unique values.

    Superfast compared to anything else including `numpy.interp`.

    Parameters
    ----------
    x : array_like of float
        (N,) array of independent values.  Must be monotonically
        increasing or decreasing.
    y : array_like of float
        (N,) array of dependent values.
    xout : float
        New independent value.

    Returns
    -------
    yout : float
        The new dependent values at `xout`.
    &quot;&quot;&quot;
    # Check for direction
    if x[0] &gt; x[-1]:  # this is ok - just a view, not copy
        x = x[::-1]
        y = y[::-1]

    if x[0] &gt; xout:
        return np.nan
    elif x[-1] &lt; xout:
        return np.nan

    if x[0] == xout:
        return y[0]

    right = -1
    for i in range(1, x.size):
        if x[i] &gt;= xout:
            right = i
            break

    rx = x[right]
    if rx == xout:
        return y[right]
    left = right - 1

    lx = x[left]
    ly = y[left]
    ry = y[right]
    dy = ry - ly

    weight = (xout - lx) / (rx - lx)
    return ly + (weight * dy)</div>



<div class="viewcode-block" id="interp_1d_point_with_error">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.interp_1d_point_with_error.html#sofia_redux.toolkit.interpolate.interpolate.interp_1d_point_with_error">[docs]</a>
@nb.njit(cache=True, nogil=False, parallel=False, fastmath=False)
def interp_1d_point_with_error(x, y, error, xout):  # pragma: no cover
    &quot;&quot;&quot;
    Perform linear interpolation at a single point with error propagation.
    `x` must be monotonically increasing or decreasing containing unique
    values.

    Superfast compared to anything else including `numpy.interp`.

    Parameters
    ----------
    x : array_like of float
        (N,) array of independent values.  Must be monotonically
        increasing or decreasing.
    y : array_like of float
        (N,) array of dependent values.
    error : array_like of float
        (N,) array of errors in dependent values.
    xout : float
        New independent value.

    Returns
    -------
    yout, eout : float, float
        The new dependent values and error at `xout`.
    &quot;&quot;&quot;
    # Check for direction
    if x[0] &gt; x[-1]:  # this is ok - just a view, not copy
        x = x[::-1]
        y = y[::-1]
        error = error[::-1]

    if x[0] &gt; xout:
        return np.nan, np.nan
    elif x[-1] &lt; xout:
        return np.nan, np.nan

    if x[0] == xout:
        return y[0], error[0]

    right = -1
    for i in range(1, x.size):
        if x[i] &gt;= xout:
            right = i
            break

    rx = x[right]
    if rx == xout:
        return y[right], error[right]
    left = right - 1

    lx = x[left]
    ly = y[left]
    ry = y[right]
    dy = ry - ly
    weight = (xout - lx) / (rx - lx)
    yout = ly + (weight * dy)

    lv = error[left]
    lv *= lv
    rv = error[right]
    rv *= rv

    vsum = lv + rv
    lv += vsum * weight * weight
    right_weight = 1.0 - weight
    rv += vsum * right_weight * right_weight
    if lv &lt; rv:
        eout = math.sqrt(lv)
    else:
        eout = math.sqrt(rv)

    return yout, eout</div>



<div class="viewcode-block" id="interp_error_1d">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.interp_error_1d.html#sofia_redux.toolkit.interpolate.interpolate.interp_error_1d">[docs]</a>
def interp_error_1d(x, error, xout, cval=np.nan):
    &quot;&quot;&quot;
    Perform linear interpolation of errors

    Parameters
    ----------
    x : array_like of float
        (N,) array of independent values.
    error : array_like of float
        (N,) array of errors in dependent values.
    xout : int or float or (array_like of (int or float))
        New independent values.  Either a scalar or array of shape (M,)
    cval : float, optional
        Value to fill in requested interpolation points outside the
        data range.

    Returns
    -------
    float or numpy.ndarray
        The new dependent error values at `xout`.  Will be either a
        float or array of shape (M,) and numpy.float64 type depending
        on the supplied `xout`.
    &quot;&quot;&quot;
    isarr = hasattr(xout, &#39;__len__&#39;)
    if not isarr:
        xout = [xout]

    x, error, xout = np.array(x), np.array(error), np.array(xout)
    shape, oshape = x.shape, xout.shape

    if error.shape != shape:
        raise ValueError(&quot;x and error shape mismatch&quot;)

    var = error ** 2
    error = np.full(oshape, float(cval))

    # determine index of xout on x
    idx = findidx(x, xout, left=np.nan, right=np.nan)
    mask = np.isfinite(idx)
    if not mask.any():
        return error

    xout, eout = xout[mask], np.empty(mask.sum())
    left = np.floor(idx[mask]).astype(int)
    right = np.ceil(idx[mask]).astype(int)

    # where no interpolation is required, just copy the values over
    pmask = left == right
    eout[pmask] = var[left][pmask]

    # now look at the points where interpolation is required
    pmask = np.logical_not(pmask, out=pmask)
    if pmask.any():
        left, right, xout = left[pmask], right[pmask], xout[pmask]
        vsum = var[left] + var[right]
        weights = (xout - x[left]) / (x[right] - x[left])
        vleft = var[left] + ((weights ** 2) * vsum)
        vright = var[right] + (((1 - weights) ** 2) * vsum)
        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;, RuntimeWarning)
            # take the smallest (not closest) value
            eout[pmask] = np.clip(vleft, 0, vright)

    error[mask] = np.sqrt(eout)
    if not isarr:
        error = error[0]

    return error</div>



<div class="viewcode-block" id="interp_error_nd">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.interp_error_nd.html#sofia_redux.toolkit.interpolate.interpolate.interp_error_nd">[docs]</a>
def interp_error_nd(points, error, xi, cval=np.nan):
    &quot;&quot;&quot;Propagate errors using Delaunay triangulation in N-dimensions

    Uses `interp_error_1d` to propagate errors in 1-dimension following
    linear interpolation, or propagates errors in N-dimensions when Delaunay
    triangulation has been used for linear interpolation.

    This is not accurate for any other type of interpolation other than the
    types mentioned above.

    Parameters
    ----------
    points : numpy.ndarray (nsamples, ndim) or Delaunay triangulation
        Coordinates of points or the pre-computed scipy.spatial.Delaunay
        triangulation.
    error : float or numpy.ndarray  (nsamples,)
        Error at each point.
    xi : numpy.ndarray (npoints, ndim)
        Points at which to interpolate data.
    cval : float, optional
        Value to fill in requested interpolation points outside the
        data range.

    Returns
    -------
    numpy.ndarray (npoints,)
    &quot;&quot;&quot;
    tri = points if isinstance(points, Delaunay) else Delaunay(points)
    ndim = tri.points.shape[1]
    simplices = tri.find_simplex(xi)
    mask = simplices != -1
    result = np.full(xi.shape[0], cval)
    if not mask.any():
        return result

    vertices = tri.simplices[simplices[mask]]

    if not hasattr(error, &#39;__len__&#39;):
        error = to_array_shape(float(error), np.max(vertices) + 1)

    # Find points that do not require interpolation
    vpoints = tri.points[vertices]
    xi_find = xi[mask]
    same_points = np.all(xi_find[:, None] == vpoints, axis=2)
    same = same_points.any(axis=1)
    if same.any():
        values = result[mask]
        values[same] = error[vertices[same_points]]
        result[mask] = values
        mask[same] = False
        if not mask.any():
            return result
        vinds = tri.simplices[simplices[mask]]

    else:
        vinds = vertices

    var = error ** 2
    var = var[vinds]

    transform = tri.transform[simplices[mask]]
    b = np.einsum(&#39;ijk,ik-&gt;ij&#39;,
                  transform[:, :ndim, :ndim],
                  xi[mask] - transform[:, ndim, :])

    weights = np.c_[b, 1 - b.sum(axis=1)]
    v0 = var + (weights ** 2) * var
    v1 = var + ((1 - weights) ** 2) * var
    result[mask] = np.sqrt(np.min([v0, v1], axis=0).sum(axis=1))
    return result</div>



<div class="viewcode-block" id="interp_error">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.interp_error.html#sofia_redux.toolkit.interpolate.interpolate.interp_error">[docs]</a>
def interp_error(points, error, xi, cval=np.nan):
    &quot;&quot;&quot;Propagate errors using linear interpolation in N-dimensions

    Allows linear interpolation of errors over 1 or multiple dimensions
    using `interp_error_1d` or `interp_error_nd`.  Note, error propagation
    is only valid for linear interpolation in 1-dimension or linear
    interpolation through Delaunay triangulation in N-dimensions.

    Parameters
    ----------
    points : numpy.ndarray (nsamples, ndim) or Delaunay triangulation
        Coordinates of points or the pre-computed scipy.spatial.Delaunay
        triangulation.
    error : float or numpy.ndarray  (nsamples,)
        Error at each point.
    xi : numpy.ndarray (npoints, ndim)
        Points at which to interpolate data.
    cval : float, optional
        Value to fill in requested interpolation points outside the
        data range.

    Returns
    -------
    numpy.ndarray (npoints,)
    &quot;&quot;&quot;
    if isinstance(points, Delaunay):
        return interp_error_nd(points, error, xi, cval=cval)

    points = np.asarray(points)
    if points.ndim == 1:
        return interp_error_1d(points, error, xi, cval=cval)
    elif points.ndim == 2:
        if points.shape[1] == 1:
            return interp_error_1d(points[:, 0], error, xi, cval=cval)
        else:
            return interp_error_nd(points, error, xi, cval=cval)
    else:
        raise ValueError(
            &quot;points must be a 1 (npoints,) or 2 (npoints, ndim) array &quot;
            &quot;unless supplying the Delaunay triangulation&quot;)</div>



<div class="viewcode-block" id="Interpolate">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.Interpolate.html#sofia_redux.toolkit.interpolate.interpolate.Interpolate">[docs]</a>
class Interpolate(object):
    &quot;&quot;&quot;
    Fast interpolation on a regular grid

    Much like scipy.interpolate.RegularGridInterpolator except better.
    Allows for cubic interpolation, omission of grid coordinates,
    and NaN handling.

    Parameters
    ----------
    args : array_like or tuple of array_like
        Either a single array whose coordinates will be determined
        by the features, or arrays of independent values followed
        by the dependent values.
    method : str, optional
        One of {&#39;linear&#39;, &#39;cubic&#39;, &#39;nearest&#39;}
    cubic : float, optional
        Defines the value of &quot;a&quot; below for the fast approximation of
        the bicubic interpolator.  a = -0.5 produces third order
        convergence with respect to the sampling interval.  The
        convolution weights are defined as::

            w(x) = (a+2)|x|^3 - (a+3)|x|^2 + 1 for |x|&lt;=1,

                   a|x|^3 - 5a|x|^2 + 8a|x| - 4a for 1&lt;|x|&lt;2,

                   0 otherwise

        If method is None, setting cubic to a float will result in
        cubic interpolation using the above weightings in each
        dimension.  The default value for `cubic` is -0.5.
    mode : str, optional
        One of {&#39;nearest&#39;, &#39;reflect&#39;, &#39;mirror&#39;, &#39;wrap&#39;, &#39;constant&#39;}
        which determines how edge conditions are handled when the
        interpolation kernel overlaps a border.  Valid values and
        behaviours are as follows:

        - &#39;nearest&#39; (a a a a | a b c d | d d d d):
          The input is extended by replicating the last pixel

        - &#39;reflect&#39; (d c b a | a b c d | d c b a):
          The input is extended by reflecting about the edge of
          the last pixel.

        - &#39;mirror&#39; (d c b | a b c d | c b a):
          The input is extended by reflecting about the center of
          last pixel.

        - &#39;wrap&#39; (a b c d | a b c d | a b c d):
          The input is extended by wrapping around the opposite
          edge.

        - `constant` (k k k k | a b c d | k k k k):
           The input is extended by filling all values beyond the
           edge with the same constant value defined by the `cval`
           parameter.

    cval : float, optional
        The value used to fill values when `mode` is &#39;constant&#39;.
    ignorenans : bool, optional
        If True, NaNs will be ignored in all calculations where possible.
    &quot;&quot;&quot;
    def __init__(self, *args, method=None, cval=np.nan, cubic=None,
                 ignorenans=True, error=None, mode=&#39;constant&#39;):

        self._valid_modes = [
            &#39;nearest&#39;, &#39;reflect&#39;, &#39;mirror&#39;, &#39;wrap&#39;, &#39;constant&#39;]
        self._valid_methods = [&#39;linear&#39;, &#39;cubic&#39;, &#39;nearest&#39;]

        if method is None:
            method = &#39;linear&#39; if cubic is None else &#39;cubic&#39;
        if method not in self._valid_methods:
            raise ValueError(&quot;Method &#39;%s&#39; is not defined&quot; % method)
        self.method = method
        if method == &#39;cubic&#39; and cubic is None:
            cubic = -0.5
        self.cubic = cubic

        if mode not in self._valid_modes:
            raise ValueError(&quot;Edge mode &#39;%s&#39; is not available&quot; % mode)
        self.mode = mode
        self._product = np.nanprod if ignorenans else np.prod
        self._sum = np.nansum if ignorenans else np.sum
        self._min = np.nanmin if ignorenans else np.min
        self.cval = cval
        self.values = None
        self.variance = None
        self.do_error = False
        self.ndim = None
        self.grid = ()
        self.dgrid = ()
        self.parse_arguments(*args, error=error)

<div class="viewcode-block" id="Interpolate.parse_arguments">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.Interpolate.html#sofia_redux.toolkit.interpolate.interpolate.Interpolate.parse_arguments">[docs]</a>
    def parse_arguments(self, *args, error=None):
        &quot;&quot;&quot;
        Parse initialization arguments.

        Parameters
        ----------
        args : array_like or tuple of array_like
            Either a single array whose coordinates will be determined
            by the features, or arrays of independent values followed
            by the dependent values.
        error : numpy.ndarray, optional
            The associated error values for the data.

        Returns
        -------
        None
        &quot;&quot;&quot;
        nargs = len(args)
        if nargs == 1:
            values = np.asarray(args[0])
            points = tuple(np.arange(side) for side in values.shape[::-1])
        else:
            values, points = np.asarray(args[-1]), args[:-1][::-1]
            if len(points) != values.ndim:
                raise ValueError(
                    &quot;There are %d grid arrays, but values has %d features&quot;
                    % (len(points), values.ndim))

        self.ndim = values.ndim
        if hasattr(values, &#39;dtype&#39;) and hasattr(values, &#39;astype&#39;):
            if not np.issubdtype(values.dtype, np.inexact):
                values = values.astype(float)

        fill_value_dtype = np.asarray(self.cval).dtype
        if (hasattr(values, &#39;dtype&#39;) and not
                np.can_cast(fill_value_dtype, values.dtype,
                            casting=&#39;same_kind&#39;)):
            raise ValueError(&quot;cval must be  of a type compatible with values&quot;)

        self.grid = self.dgrid = ()
        for i, p in enumerate(points):
            if not np.all(np.diff(p) &gt; 0.):
                raise ValueError(&quot;The points in dimension %d must be strictly &quot;
                                 &quot;ascending&quot; % i)
            if not np.asarray(p).ndim == 1:
                raise ValueError(&quot;The points in dimension %d must be &quot;
                                 &quot;1-dimensional&quot; % i)
            if not values.shape[i] == len(p):
                raise ValueError(&quot;There are %d grid points and %d values in &quot;
                                 &quot;dimension %d&quot; % (len(p), values.shape[i], i))
            g = np.asarray(p)
            d = np.empty(g.shape)
            d[:-1] = np.diff(g)
            d[-1] = d[-2]
            self.grid += g,
            self.dgrid += d,

        self.set_values_and_error(values, error=error)</div>


<div class="viewcode-block" id="Interpolate.set_values_and_error">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.Interpolate.html#sofia_redux.toolkit.interpolate.interpolate.Interpolate.set_values_and_error">[docs]</a>
    def set_values_and_error(self, values, error=None):
        &quot;&quot;&quot;
        Set new interpolating values and error.

        Parameters
        ----------
        values : numpy.ndarray (int or float)
            The new values to set.  Must be the same shape as the interpolation
            grid.
        error : numpy.ndarray (int or float), optional
            Optional error values to set.

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.set_values(values)
        if error is not None:
            self.variance = np.full_like(self.values, np.nan)
            self.variance[(slice(0, -1),) * values.ndim] = np.asarray(
                error ** 2)
            self.do_error = True
        else:
            self.variance = None
            self.do_error = False</div>


<div class="viewcode-block" id="Interpolate.set_values">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.Interpolate.html#sofia_redux.toolkit.interpolate.interpolate.Interpolate.set_values">[docs]</a>
    def set_values(self, values):
        &quot;&quot;&quot;
        Reset the interpolation values only.

        Parameters
        ----------
        values : numpy.ndarray, optional
            The new values to set.  Must be the same shape as the interpolation
            grid.

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.values = np.full([s + 1 for s in values.shape], self.cval,
                              dtype=values.dtype)
        self.values[(slice(0, -1),) * values.ndim] = values</div>


<div class="viewcode-block" id="Interpolate.__call__">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.Interpolate.html#sofia_redux.toolkit.interpolate.interpolate.Interpolate.__call__">[docs]</a>
    def __call__(self, *args, method=None, cubic=None, mode=None):
        &quot;&quot;&quot;
        Interpolation at coordinates.

        Parameters
        ----------
        args : array_like or tuple of array_like
            The coordinates to sample the gridded data at.  The order of
            features follow the &#39;xy&#39; rather than &#39;ij&#39; convention.  For
            example, arguments for two-dimensional data should be supplied
            in the order (x, y).
        method : str
            The method of interpolation to perform.  One of {&#39;linear&#39;, &#39;cubic&#39;,
            &#39;nearest&#39;}.
        &quot;&quot;&quot;
        if method is None:
            method = self.method if cubic is None else &#39;cubic&#39;
        if method not in self._valid_methods:
            raise ValueError(&quot;Method &#39;%s&#39; is not defined&quot; % method)
        self.method = method

        if self.method == &#39;cubic&#39;:
            if cubic is not None:
                self.cubic = cubic
            elif self.cubic is None:
                self.cubic = -0.5

        if mode is None:
            mode = self.mode
        if mode not in self._valid_modes:
            raise ValueError(&quot;Edge mode %s is not available&quot; % mode)
        self.mode = mode

        if len(args) != self.ndim:
            raise ValueError(
                &quot;require %i input arguments for %i-D data&quot; %
                (self.ndim, self.ndim))

        shape_in = np.asarray(args[0]).shape
        xi = stack(*args, copy=False)[::-1]

        indices, norm_distances = self._find_indices(xi)
        result = None
        if method == &#39;linear&#39;:
            result = self._evaluate_linear(indices, norm_distances)
        elif method == &#39;nearest&#39;:
            result = self._evaluate_nearest(indices, norm_distances)
        elif method == &#39;cubic&#39;:
            result = self._evaluate_cubic(indices, norm_distances)

        return result.reshape(shape_in)</div>


<div class="viewcode-block" id="Interpolate.cubic_weights">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.Interpolate.html#sofia_redux.toolkit.interpolate.interpolate.Interpolate.cubic_weights">[docs]</a>
    @staticmethod
    def cubic_weights(distances, a=-0.5):
        d = np.abs(np.asarray(distances))
        w = np.zeros(d.shape)
        i = d &lt;= 1
        w[i] = ((a + 2) * d[i] ** 3) - ((a + 3) * d[i] ** 2) + 1
        i = (d &gt; 1) &amp; (d &lt; 2)
        w[i] = (a * d[i] ** 3) - (5 * a * d[i] ** 2) + (8 * a * d[i]) - (4 * a)
        return w</div>


    def _evaluate_cubic(self, indices, norm_distances, cubic=-0.5):
        indset = itertools.product(*indices)
        weights = itertools.product(*[self.cubic_weights(d, a=cubic)
                                      for d in norm_distances])
        s = indices[0].shape[0] ** self.ndim, indices[0].shape[1]
        values = np.empty(s, dtype=self.values.dtype)
        for vals, inds, wts in zip(values, indset, weights):
            vals[:] = self.values[inds] * self._product(wts, axis=0)

        return self._sum(values, axis=0)

    def _evaluate_linear(self, indices, norm_distances):
        indset = itertools.product(*indices)
        weights = itertools.product(*[abs(1 - d) for d in norm_distances])
        s = indices[0].shape[0] ** self.ndim, indices[0].shape[1]
        values = np.empty(s, dtype=self.values.dtype)

        for vals, inds, wts in zip(values, indset, weights):
            vals[:] = self.values[inds] * self._product(wts, axis=0)
        return self._sum(values, axis=0)

    def _evaluate_nearest(self, indices, norm_distances):
        idx_res = []
        select_points = np.arange(indices[0].shape[1])
        for i, yi in zip(indices, norm_distances):
            idx = np.argmin(yi, axis=0)
            idx_res.append(i[idx, select_points])
        return self.values[tuple(idx_res)]

    def _find_indices(self, xi):
        # find relevant interpolants for xi
        indices = []
        # compute distance to lower edge in unity units
        norm_distances = []

        dx = 2 if self.method == &#39;cubic&#39; else 1
        offsets = np.arange(-dx, dx)

        # iterate through features
        for x, grid, dgrid in zip(xi, self.grid, self.dgrid):
            highlim = grid.size - 1
            i = np.searchsorted(grid, x)
            l0 = i == 0
            h0 = i == grid.size
            i = i[:, None] + offsets[None]
            inds = np.clip(i, 0, highlim)
            d = (x[:, None] - grid[inds]) / dgrid[inds]
            d = abs(d[:, dx]) % 1
            d[l0] = 0
            d[h0] = 1
            d = abs(d[:, None] + offsets)

            low = i &lt; 0
            high = i &gt; highlim

            if self.mode == &#39;nearest&#39;:
                pass

            elif self.mode == &#39;reflect&#39;:
                inds[low] = abs(i[low])
                inds[high] = 2 * highlim - i[high]

            elif self.mode == &#39;mirror&#39;:
                inds[low] = abs(i[low] + 1)
                inds[high] = 2 * highlim - i[high] + 1

            elif self.mode == &#39;wrap&#39;:
                inds[low] = highlim + i[low] + 1
                inds[high] = i[high] - highlim - 1

            elif self.mode == &#39;constant&#39;:
                low |= l0[:, None]
                high |= h0[:, None]
                inds[low] = -1
                inds[high] = -1

            else:
                raise ValueError(&quot;unknown edge mode (%s)&quot; % self.mode)

            indices.append(inds.T)
            norm_distances.append(d.T)

        return indices, norm_distances</div>



<div class="viewcode-block" id="tabinv">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.tabinv.html#sofia_redux.toolkit.interpolate.interpolate.tabinv">[docs]</a>
def tabinv(array, xvals, missing=None, fast=True):
    &quot;&quot;&quot;
    Find the effective index of a function value in an ordered vector with
    NaN handling.

    Parameters
    ----------
    array : array_like
        The array to be searched.  Should be monotonic increasing or
        decreasing.
    xvals : the function value(s) whose effective index is sought
    missing : float or int, optional
        Value to return if outside the limits.  Default uses constant
        value of the first or last value in the array.  Only pertinent
        if `fast` is True.
    fast : bool, optional
        If False, uses `findidx` to check if x in monotonic and does
        not allow extrapolation beyond the limits of `array`.  NaNs
        will break monotonic check if not limited to padding on the
        edges of `array`.  If fast is True, np.interp is used without
        any form of error checking.

    Returns
    -------
    numpy.ndarray
        The effective index or indices of `array`

    Examples
    --------
    &gt;&gt;&gt; from sofia_redux.toolkit.interpolate.interpolate import tabinv
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import pytest
    &gt;&gt;&gt; x = [np.nan, np.nan, 1, 2, np.nan, 3, np.nan, np.nan]
    &gt;&gt;&gt; tabinv(x, 1.5)
    2.5
    &gt;&gt;&gt; with pytest.raises(ValueError):
    ...     tabinv(x, 1.5, fast=False)
    ...
    &gt;&gt;&gt; x = [np.nan, np.nan, 1, 2, 3, np.nan, np.nan]
    &gt;&gt;&gt; tabinv(x, 1.5, fast=False)
    2.5
    &quot;&quot;&quot;
    array = np.asarray(array, dtype=float)
    if array.ndim != 1:
        raise ValueError(&quot;Array must have 1-dimension&quot;)
    if fast:
        return np.interp(xvals, array, np.arange(len(array)),
                         left=missing, right=missing)
    else:
        idx = nantrim(array, 2, bounds=True)
        return findidx(array[idx[0]: idx[1]], xvals) + idx[0]</div>



<div class="viewcode-block" id="findidx">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.interpolate.interpolate.findidx.html#sofia_redux.toolkit.interpolate.interpolate.findidx">[docs]</a>
def findidx(ix, ox, left=0, right=None):
    &quot;&quot;&quot;
    Finds the effective index of a function value in an ordered array.

    Formerly tabinv.  findidx will abort if xi is not monotonic.
    Equality of neighboring values in xi is allowed but results may
    not be unique.  This requirement may mean that xi padded with
    zeroes could cause findidx to abort.

    A binary search is used to find the values xi[i] and xi[i+1] where
    xi[i] &lt; xo &lt; xi[i+1].  Output (ieff) is then computed using linear
    interpolation between i and i+1::

        ieff = i + (xo - xi[i]) / (xi[i+1] - xi[i])

    Let n = number of elements in xi::
        if (x &lt; xi[0]) or (x &gt; xi[n-1]) then xo = NaN

    Parameters
    ----------
    ix : array_like of float
        (N,) The array to be searched, must be monotonic increasing or
        decreasing.
    ox : (array_like of float) or float
         (M,) The function value(s) whose effective index is sought.
    left : float, optional
        Value to return for ox &lt; min(ix).  default is 0
    right : float, optional
        Value to return for ox &gt; max(ix).  default is len(ix) - 1

    Returns
    -------
    float or numpy.ndarray
        (M,) The effective index or indices of xo in xi.  Note that
        output type will be float and will need to changed to
        integer in order to be used for indexing another array.
    &quot;&quot;&quot;
    ix = np.asarray(ix)
    n = ix.size

    if np.isnan(ix).any():
        raise ValueError(&quot;NaNs detected: cannot test for mononcity&quot;)

    if hasattr(ox, &#39;__len__&#39;):
        ox = np.array(ox)
        shape = ox.shape
        ox = ox.ravel()
    else:
        ox = np.array([ox])
        shape = None

    if n &lt;= 1:
        return 0.0 if shape is None else np.zeros(shape)

    # Initialize binary search area and compute number of divisions needed
    ileft, iright = np.zeros((2, ox.size), dtype=int)
    ndivisions = int(np.log10(n) / np.log10(2) + 1)

    # Test for monotonicity
    with warnings.catch_warnings():
        warnings.simplefilter(&#39;ignore&#39;, RuntimeWarning)
        i = (ix - np.roll(ix, 1))[1:]
        a = i &gt;= 0
        if a.sum() == (n - 1):  # test for increasing array
            np.add(iright, n - 1, out=iright)
        else:  # test for decreasing array
            a = i &lt;= 0
            if a.sum() == (n - 1):
                np.add(ileft, n - 1, out=ileft)
            else:
                raise ValueError(&quot;xi is not monotonic&quot;)

        # Perform binary search by successively dividing search
        # interval in half
        for i in range(ndivisions):
            idiv = (ileft + iright) // 2
            xval = ix[idiv]
            less, greater = ox &lt;= xval, ox &gt; xval
            np.multiply(ileft, less, out=ileft)
            np.add(ileft, idiv * greater, out=ileft)
            np.multiply(iright, greater, out=iright)
            np.add(iright, idiv * less, out=iright)

        # Interpolate between interval of width = 1
        # value on left and right sides
        xleft, xright = ix[ileft], ix[iright]
        iszero = xleft == xright
        ieff = ((xright - ox) * ileft).astype(float)
        np.add(ieff, (ox - xleft) * iright, out=ieff)
        np.add(ieff, iszero * ileft, out=ieff)
        np.divide(ieff, (xright - xleft + iszero), out=ieff)

        # do not allow extrapolation beyond ends
        np.clip(ieff, 0, n - 1, out=ieff)
        past_edge = ox &lt; np.nanmin(ix)
        ieff[past_edge] = left
        past_edge[...] = ox &gt; np.nanmax(ix)
        if right is None:
            ieff[past_edge] = n - 1
        else:
            ieff[past_edge] = right

        return ieff[0] if shape is None else np.reshape(ieff, shape)</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.2.6. &nbsp;
    Last built 05 Feb 2024. <br/>
  </p>
</footer>
  </body>
</html>