<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>polyfillaa &#8212; sofia_redux v1.3.4.dev38+g92ea2f4</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    
    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=6aa39468"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <link rel="icon" href="../_static/redux.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="polygon_area" href="sofia_redux.toolkit.image.fill.polygon_area.html" />
    <link rel="prev" title="polyclip" href="sofia_redux.toolkit.image.fill.polyclip.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://irsa.ipac.caltech.edu/Missions/sofia.html"></a></li>
    <li><a title="General Index" href="../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li class="right">
	<a href="sofia_redux.toolkit.image.fill.polygon_area.html" title="polygon_area">
	  next &raquo;
	</a>
      </li>
      <li class="right">
	<a href="sofia_redux.toolkit.image.fill.polyclip.html" title="polyclip">
	  &laquo; previous
	</a>
	 |
      </li>
      <li>
	<a href="../index.html">sofia_redux v1.3.4.dev38+g92ea2f4</a>
	 &#187;
      </li>
      <li><a href="../sofia_redux/index.html" >SOFIA Redux</a> &#187;</li>
      <li><a href="../manuals/exes/developers/developers.html" accesskey="U">EXES Redux Developer’s Manual</a> &#187;</li>
      
      <li>polyfillaa</li> 
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="polyfillaa">
<h1>polyfillaa<a class="headerlink" href="#polyfillaa" title="Link to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="sofia_redux.toolkit.image.fill.polyfillaa">
<span class="sig-prename descclassname"><span class="pre">sofia_redux.toolkit.image.fill.</span></span><span class="sig-name descname"><span class="pre">polyfillaa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">px</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">py</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">area</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sofia_redux/toolkit/image/fill.html#polyfillaa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sofia_redux.toolkit.image.fill.polyfillaa" title="Link to this definition">¶</a></dt>
<dd><p>Finds all pixels at least partially inside a specified polygon</p>
<p>Find the number of vertices for each polygon and then loop through
groups of polygons with an equal sides.  Then for each group of
similar sided polygons:</p>
<ol class="arabic">
<li><p>Create a shared pixel grid to be used by all polygons in the
group.  The size of the grid is determined by the maximum
range of polygon widths and heights in the group.</p></li>
<li><p>For each polygon edge, calculate where it crosses the left
and bottom edges of the each grid cell.</p></li>
<li><p>Determine whether the vertices are inside the grid points.
The crossings determined in step 2 can be used to determine
whether the lower-left grid points are contained within a
polygon.  In this case, a grid point is said to be in the
polygon if there are an odd number of intersection points
with the polygon along the y-coordinate of the grid point.</p></li>
<li><p>Remember that we have only calculated polygon crossings on the
left and lower edges of each cell and whether the lower-left
corner of a cell is enclosed in the polygon.  To avoid
duplicate calculations, take note of the following facts:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>If a lower-left grid point (gp) is enclosed in the polygon
then the lower-right gp of the cell to the left, the
upper-right gp of the cell to the lower-left, and the
upper-left gp of the cell below must also be enclosed.</p></li>
<li><p>If the polygon crosses the left edge of the cell, it
must also cross the right edge of the cell to the left.</p></li>
<li><p>If the polygon crosses the bottom edge of the cell, it
must also cross the top edge of the cell below it.</p></li>
</ol>
</div></blockquote>
</li>
<li><p>Given all of these points, it is clear that the maximum number
of clipped polygon vertices will be equal to 2 times the number
of polygon vertices of the input group of polygons since each
edge can cross a maximum of 2 cell sides, or be clipped to
where one vertex remains inside the cell and the other is
located on the edge of the cell.  If both vertices are inside
the cell then that edge remains unchanged.  Therefore the
maximum number of clipped polygon vertices occurs when all
polygon edges intersect 2 cell edges (imagine two superimposed
squares and then rotating one by 45 degrees).  We create a
3D output array containing the new vertices for each polygon
and for each pixel and fill it in the following order:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>vertices that are inside</p></li>
<li><p>grid points that are inside</p></li>
<li><p>clipped vertices</p></li>
</ol>
</div></blockquote>
</li>
<li><p>If we do not need to calculate area, then we can stop here
since we have all the new vertices.  However, if we do need
to calculate area, then these points need to be arranged in
clockwise or anti-clockwise order.  This is done by ordering
the points based on angle with respect to the center-of-mass
of the points.  As a side note, this takes up a significant
amount of processing time (the sorting, not the angle).  I
attempted many alternate solutions to this by not changing
the original order of the input vertices and clipping
in-place.  One of the most promising methods was to encode
where a vertex was in relation to the cell and then clip
based on that, ordering by keeping points in the following
manner and looping around the edges of a cell in the order
bottom -&gt; left -&gt; top -&gt; right:</p>
<blockquote>
<div><blockquote>
<div><p>outside -&gt; inside = keep the inside and clipped vertices
inside -&gt; outside = clipped vertex only
inside -&gt; inside = keep the second inside point
outside -&gt; outside = keep both clipped vertices</p>
</div></blockquote>
<p>The problem occurs with whether grid points (corners) should be
included or not, and where they are located in the final order
of points.  This can be achieved by encoding a vertex location
relative to the cell as bits where 1 indicates outside and 0
indicates inside in the order bottom-left-top-right. So for
example, 0000 indicates a point is inside the cell and 0100
indicates a vertex is to the left of the cell.  codes
containing two 1’s indicate corners, and a set of rules can then
be established determining whether a gp is inside or outside
based on the code combination of vertices for one edge.</p>
<p>However, in order to achieve vectorization, this requires
storing at least 16 times the amount of initial data in the
cache (number of polygons * area of polygon * 16) which can
be huge and clumsy.  We can get around this with loops, but
this is not efficient with Python.  Therefore, it is quicker
and safer to just use a sort on the angle and be done with it.
If you think there’s a better solution then please feel free
to implement it (and tell me too for my own curiosity).</p>
</div></blockquote>
</li>
<li><p>Calculate area using the shoelace formula:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A = 0.5 * sum( x_i * y_(j+1)) - sum(x_(i+1) * y(j))|
</pre></div>
</div>
</li>
<li><p>Finally, organize the results by lumping together polygons
based on the number of cells enclosed within.  This allows
us to grab which cells belong to which polygons quickly.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>px</strong><span class="classifier">array_like of (int or float)</span></dt><dd><p>Contains the x-coordinates of the polygons.  May be provided as a flat
array if <code class="xref py py-obj docutils literal notranslate"><span class="pre">start_indices</span></code> is provided. Alternitvely, a 2-level nested
list may be provided with each sublist containing vertices for a
single polygon.</p>
</dd>
<dt><strong>py</strong><span class="classifier">array_like of (int or float)</span></dt><dd><p>Contains the y-coordinates of the polygons.  May be provided as a flat
array if <code class="xref py py-obj docutils literal notranslate"><span class="pre">start_indices</span></code> is provided. Alternitvely, a 2-level nested
list may be provided with each sublist containing vertices for a
single polygon.</p>
</dd>
<dt><strong>xrange</strong><span class="classifier">array_like, optional</span></dt><dd><p>(2,) [lower x-limit, upper x-limit] array defining the x range
on which the polygon is superimposed (number of columns).
size of the pixel grid on which the polygon is superimposed
Supplying it will clip all x results to within
xrange[0]-&gt;xrange[1].</p>
</dd>
<dt><strong>yrange</strong><span class="classifier">array_like, optional</span></dt><dd><p>(2,) [lower y-limit, upper y-limit] array defining the y range
on which the polygon is superimposed (number of rows).
size of the pixel grid on which the polygon is superimposed
Supplying it will clip all y results to within
yrange[0]-&gt;yrange[1].</p>
</dd>
<dt><strong>start_indices</strong><span class="classifier">array_like of int, optional</span></dt><dd><p>Multiple polygon shapes may be specified with the <code class="xref py py-obj docutils literal notranslate"><span class="pre">polygons</span></code>
parameter by specifying indices in the first dimension of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">polygons</span></code> which should be considered a first vertex of a
polygon.  For example, the nth polygon consists of vertices
at polygons[n:(n+1)].  Note that <code class="xref py py-obj docutils literal notranslate"><span class="pre">start_indices</span></code> will be sorted
and that the last index (start_indices[-1]) gives the last point
belonging to start_indices[-2].  The last polygons vertex is not
automatically appended.  i.e. the last polygon is
polygons[start_indices[-2]:start_indices[-1]], not
polygons[start_indices[-1]:].</p>
</dd>
<dt><strong>area</strong><span class="classifier">bool, optional</span></dt><dd><p>if True, return an additional dictionary containing the area</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>polygon, [areas]</strong><span class="classifier">(2-tuple of (dict or array)) or (dict or array)</span></dt><dd><dl class="simple">
<dt>A dictionary containing the output:</dt><dd><p>polygon index (int) -&gt; tuples of (y, x) grid coordinates contained
within each polygon</p>
</dd>
<dt>areas (optional if <code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code> is set to True)</dt><dd><dl class="simple">
<dt>polygon index (int) -&gt; list of pixel areas in the same order as</dt><dd><p>given by output indices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>I vectorized the crap out of this thing and removed redundancies
so it could run faster than the IDL version.  The IDL version was
loop driven which is generally a no no, but it this case it was
very very well done and also able to use C compiled clipping code.
Python looping using the same method could not even slightly keep up.
For example, 50,000 polygons on a 256, 256 grid, where each polygon
covered an area of 3x3 grid pixels took 20 seconds using the Python
equivalent of the IDL code with all the speed saving tricks / data
types and objects available.  In comparison, IDL took ~3 seconds
while this method took ~1 second.  If you want to attempt speeding
it up further then the main choking point is the sorting of angles
when calculating area.  If you want to use the old method for
calculating output polygons/area, replace the main body of code
after normalization to a regular pixel grid to loop through all
polygons, then all pixels covered by the polygon and calculate
the area using <code class="xref py py-obj docutils literal notranslate"><span class="pre">sofia_redux.toolkit.polygon.polyclip</span></code>.</p>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">polyfillaa</a><ul>
<li><a class="reference internal" href="#sofia_redux.toolkit.image.fill.polyfillaa"><code class="docutils literal notranslate"><span class="pre">polyfillaa()</span></code></a></li>
</ul>
</li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right">
    <a href="../_sources/api/sofia_redux.toolkit.image.fill.polyfillaa.rst.txt"
       rel="nofollow">Page Source</a> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.2.6. &nbsp;
    Last built 05 Feb 2024. <br/>
  </p>
</footer>
  </body>
</html>