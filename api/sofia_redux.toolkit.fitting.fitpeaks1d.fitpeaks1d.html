<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>fitpeaks1d &#8212; sofia_redux v1.3.4.dev38+g92ea2f4</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    
    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=6aa39468"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <link rel="icon" href="../_static/redux.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="medabs_baseline" href="sofia_redux.toolkit.fitting.fitpeaks1d.medabs_baseline.html" />
    <link rel="prev" title="get_final_model" href="sofia_redux.toolkit.fitting.fitpeaks1d.get_final_model.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://irsa.ipac.caltech.edu/Missions/sofia.html"></a></li>
    <li><a title="General Index" href="../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li class="right">
	<a href="sofia_redux.toolkit.fitting.fitpeaks1d.medabs_baseline.html" title="medabs_baseline">
	  next &raquo;
	</a>
      </li>
      <li class="right">
	<a href="sofia_redux.toolkit.fitting.fitpeaks1d.get_final_model.html" title="get_final_model">
	  &laquo; previous
	</a>
	 |
      </li>
      <li>
	<a href="../index.html">sofia_redux v1.3.4.dev38+g92ea2f4</a>
	 &#187;
      </li>
      <li><a href="../sofia_redux/index.html" >SOFIA Redux</a> &#187;</li>
      <li><a href="../manuals/exes/developers/developers.html" accesskey="U">EXES Redux Developer’s Manual</a> &#187;</li>
      
      <li>fitpeaks1d</li> 
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="fitpeaks1d">
<h1>fitpeaks1d<a class="headerlink" href="#fitpeaks1d" title="Link to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="sofia_redux.toolkit.fitting.fitpeaks1d.fitpeaks1d">
<span class="sig-prename descclassname"><span class="pre">sofia_redux.toolkit.fitting.fitpeaks1d.</span></span><span class="sig-name descname"><span class="pre">fitpeaks1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npeaks=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xrange=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_width=(None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">None)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peak_class=&lt;class</span> <span class="pre">'astropy.modeling.functional_models.Gaussian1D'&gt;</span> <span class="pre">Name:</span> <span class="pre">Gaussian1D</span> <span class="pre">N_inputs:</span> <span class="pre">1</span> <span class="pre">N_outputs:</span> <span class="pre">1</span> <span class="pre">Fittable</span> <span class="pre">parameters:</span> <span class="pre">('amplitude'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'stddev')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">box_class=&lt;class</span> <span class="pre">'astropy.modeling.functional_models.Box1D'&gt;</span> <span class="pre">Name:</span> <span class="pre">Box1D</span> <span class="pre">N_inputs:</span> <span class="pre">1</span> <span class="pre">N_outputs:</span> <span class="pre">1</span> <span class="pre">Fittable</span> <span class="pre">parameters:</span> <span class="pre">('amplitude'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'x_0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'width')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">box_width=(None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_class=&lt;class</span> <span class="pre">'astropy.modeling.functional_models.Const1D'&gt;</span> <span class="pre">Name:</span> <span class="pre">Const1D</span> <span class="pre">N_inputs:</span> <span class="pre">1</span> <span class="pre">N_outputs:</span> <span class="pre">1</span> <span class="pre">Fittable</span> <span class="pre">parameters:</span> <span class="pre">('amplitude'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binit=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_args=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_kwargs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitting_class=&lt;class</span> <span class="pre">'astropy.modeling.fitting.LevMarLSQFitter'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outlier_func=&lt;function</span> <span class="pre">robust_masking&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outlier_iter=3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseline_func=&lt;function</span> <span class="pre">medabs_baseline&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guess_func=&lt;function</span> <span class="pre">guess_xy_mad&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optional_func=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitter_kwargs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fitopts=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_kwargs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sofia_redux/toolkit/fitting/fitpeaks1d.html#fitpeaks1d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sofia_redux.toolkit.fitting.fitpeaks1d.fitpeaks1d" title="Link to this definition">¶</a></dt>
<dd><p>Fit peaks (and optionally background) to a 1D set of data.</p>
<p>The user may fit for 1 or multiple peaks in the input data using
using an array of different peak models and also fit for a model
of the background.  There are a large number of standard models
available for both, or the user may define their own models if
necessary.  By default, we fit for Gaussian peaks and a
constant background.</p>
<p>The intention of <a class="reference internal" href="#sofia_redux.toolkit.fitting.fitpeaks1d.fitpeaks1d" title="sofia_redux.toolkit.fitting.fitpeaks1d.fitpeaks1d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fitpeaks1d</span></code></a> is to provide a highly customizable
peak fitting utility for one dimensional data.  The basic procedure
is split into two phases:  the search phase and the refinement phase.</p>
<p>During the search phase an attempt is made to get a good first estimate
of where the most prominent peaks lie in the data along with
estimates of their properties.  Initial positions can be
supplied by the user via <code class="xref py py-obj docutils literal notranslate"><span class="pre">guess</span></code>, but may also be derived via
the <code class="xref py py-obj docutils literal notranslate"><span class="pre">guess_func</span></code> algorithm which is also definable by the user.
By default, candidate positions are determined as
max(abs(y - median(y))).  The basic procedure is as follows:</p>
<ol class="arabic simple">
<li><p>Remove a baseline from the y data via the <code class="xref py py-obj docutils literal notranslate"><span class="pre">baseline_func</span></code>
function.  At this early stage, we are only really interested
in peak characteristics or even just where they kind-of are.
The default baseline removal function is to subtract the
median although it is completely reasonable to use many other
methods depending on your data.  This baseline_func may also
transform the initial data set to something a little more
suitable for finding peaks.  Users may wish to smooth or
filter the data, or perform some other kind of transform.
By default the data is set to y = abs(y - median(y)) as
we do not know if we’re searching for positive or negative
peaks.</p></li>
<li><p>Guess where peaks may lie along the x-axis.  These estimates
can be provided directly by the user, or derived via the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">guess_func</span></code> algorithm.  This algorithm should take the
(x, y) data set and return a single (x0, y0) coordinate
giving the x position and amplitude of the most prominent
peak candidate in the data.  In the default case this is
simply y0 = max(y) and x0 = where(y0).</p></li>
<li><p>Fit a peak using (x0, y0) as an initial condition.  Store
the peak properties and then subtract a model of the peak
from the data and go back to step 2.  Only break this loop
once the cycle has completed <code class="xref py py-obj docutils literal notranslate"><span class="pre">npeaks</span></code> times.  This will
hopefully yield the <code class="xref py py-obj docutils literal notranslate"><span class="pre">npeaks</span></code> most prominent peaks in the
data.  After fitting we should have a more exact (x1, y1)
position for each peak.</p></li>
<li><p>Take the x1 position of each peak derived in step 3 and
interpolate it back onto the original data set before we
changed it in step 1.  Subtract the derived baseline from
this value and we should then have a good estimate of the
(x, y) position for each peak in relation to the real
dataset.</p></li>
<li><p>If the user wishes to fit a background to the data, we
get an estimate of the background fit parameters by
subtracting models of each peak from the original dataset
and then fitting the desired background model to the
residual.</p></li>
</ol>
<p>During the refinement phase, a final model is created
from all initial peak fits and an
optional background.  If a background is requested, an initial
estimate of its parameters is derived by fitting the model
on y - fit(peak_estimates).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x: array_like of float</strong></dt><dd><p>(N,) array of independent values.</p>
</dd>
<dt><strong>y</strong><span class="classifier">array_like of float</span></dt><dd><p>(N,) array of independent values.</p>
</dd>
<dt><strong>npeaks</strong><span class="classifier">int, optional</span></dt><dd><p>The number of peaks to find.  Set to None to find a single
(most prominent) peak.  Peaks are returned in the order
most prominent -&gt; least prominent.</p>
</dd>
<dt><strong>xrange</strong><span class="classifier">2-tuple of (int or float), optional</span></dt><dd><p>The (minimum, maximum) range of values in x where a fitted
peak will be valid.  Set to None to use the full range of
valid (finite) data.</p>
</dd>
<dt><strong>peak_class</strong><span class="classifier">astropy.modeling.Fittable1DModel, optional</span></dt><dd><p>Class of peak model.  The default is
<code class="xref py py-obj docutils literal notranslate"><span class="pre">astropy.modeling.models.Gaussian1D</span></code>.</p>
</dd>
<dt><strong>box_width</strong><span class="classifier">float or int or (2-tuple of (str, float)), optional</span></dt><dd><p>If int or float, specifies the width of <code class="xref py py-obj docutils literal notranslate"><span class="pre">box_model</span></code>. If specifed
as a 2-tuple of (str, float), the first specifies a
parameter of the model that will be taken and multiplied by
the second element of the 2-tuple (float) to define the width
of the box.  For example (‘stddev’, 3) for the Gaussian1D model
would limit the range of the model to 3 * FWHM.  This is highly
recommended when fitting continuous or wide functions.  Note
that this will not be applied when the refined model is
fitted in parallel, since that kind of negates the whole
point of fitting in parallel in the first place.</p>
</dd>
<dt><strong>min_width</strong><span class="classifier">2-tuple of (str or None, float or None), optional</span></dt><dd><p>Set a lower limit on the width of each peak.  Set to None for
no lower limit.  min_width[0] is the name of the parameter in
the peak model governing width (str).  Set this to None to
autodetect the parameter name if using a standard model.
min_width[1] is the value to set.  If set to None, half of the
median separation of sorted unique <code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code> samples will be used.</p>
</dd>
<dt><strong>box_class</strong><span class="classifier">astropy.modeling.Fittable1DModel, optional</span></dt><dd><p>Class for filtering the peak model.  Will be applied as
peak_model * box_model.  This is only applied during the initial
search stage.  The width of the box is defined by <code class="xref py py-obj docutils literal notranslate"><span class="pre">max_region</span></code>.
The default is astropy.modeling.models.Box1D.</p>
</dd>
<dt><strong>background_class</strong><span class="classifier">astropy.modeling.Fittable1DModel, optional</span></dt><dd><p>Class for describing the background.  Will be applied as
peak_model + background in the final refined fitting.  Note that
it will only be fitted to the area of interest around each peak
(<code class="xref py py-obj docutils literal notranslate"><span class="pre">max_region</span></code>).  Disable background fitting by supplying <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>.
The default is to fit a constant background using
astropy.modeling.models.Const1D.  NOTE: you can supply a model
instance rather than class in order to fit polynomial backgrounds
as the number of polynomial parameters are dependent on the
polynomial order.  For example, in order to fit a 3rd order
polynomial, set background_class=Polynomial1D(3).</p>
</dd>
<dt><strong>binit</strong><span class="classifier">array_like of float, optional</span></dt><dd><p>A user guess at background parameters</p>
</dd>
<dt><strong>bg_args</strong><span class="classifier">tuple, optional</span></dt><dd><p>If the background class requires arguments, they should be supplied
here as a tuple.</p>
</dd>
<dt><strong>bg_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Optional keyword arguments to pass into the background model
during initialization.</p>
</dd>
<dt><strong>fitting_class</strong><span class="classifier">class of fitting object</span></dt><dd><p>Typically a “solver” from scipy.optimize or astropy.modeling
that when instatiated will create a solver such that:</p>
<blockquote>
<div><p>fitted_model = solver(model, x, y)</p>
</div></blockquote>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations for the solver to attempt before
quitting.  Set to None to use the default for each solver class.</p>
</dd>
<dt><strong>outlier_func</strong><span class="classifier">function, optional</span></dt><dd><p>A function of the form data_out = outlier_func(data_in).  You
may do anything at all to the data such as clipping, but perhaps
the simplest option is to convert the data to a np.ma.MaskedArray
and set the mask (True=bad) while returning the original data
untouched.  The default is to use <code class="xref py py-obj docutils literal notranslate"><span class="pre">robust_masking</span></code> which is a
basic wrapper for <code class="xref py py-obj docutils literal notranslate"><span class="pre">mc.find_outliers</span></code>.</p>
</dd>
<dt><strong>robust</strong><span class="classifier">dict or anything, optional</span></dt><dd><p>Supplying anything other than <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a> will turn on outlier rejection
for the solver.  If <code class="xref py py-obj docutils literal notranslate"><span class="pre">robust</span></code> is a dict, then it should contain
optional keyword arguments that would be supplied to <code class="xref py py-obj docutils literal notranslate"><span class="pre">outlier_func'.</span>
<span class="pre">For</span> <span class="pre">example,</span> <span class="pre">the</span> <span class="pre">default</span> <span class="pre">`robust_masking</span></code> outlier rejection function
takes the <code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold</span></code> keyword.  To turn on outlier rejection you
could just set robust=True, but if you wanted to change threshold to
10, then set robust={‘threshold’: 10}.  Setting robust=None turns
off outlier rejection (default).</p>
</dd>
<dt><strong>outlier_iter</strong><span class="classifier">int, optional</span></dt><dd><p>The maximum number of iterations for the solver when rejecting
outlers.  Defaults to 3.</p>
</dd>
<dt><strong>guess</strong><span class="classifier">array_like of float, optional</span></dt><dd><p>An array where each element gives a guess at an initial
<code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code> position for the peak.  If there are less guesses than
<code class="xref py py-obj docutils literal notranslate"><span class="pre">npeaks</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">guess_func</span></code> will be used after the inital guesses
have been taken.  If there are more guesses than <code class="xref py py-obj docutils literal notranslate"><span class="pre">npeaks</span></code>, then
only guess[:npeaks] will be used.</p>
</dd>
<dt><strong>baseline_func</strong><span class="classifier">function, optional</span></dt><dd><p>A function of the form used during the initial search phase:</p>
<blockquote>
<div><p>ysearch, baseline = baseline_func(x, y)</p>
</div></blockquote>
<p>This function should remove a baseline from the data so that
we mitigate effects from the background as much as possible
while keeping the structure of the peaks.  In the default
case, the baseline is taken as the median in y.  This baseline
should be subtracted from y and then the user may transform
y as they see fit to allow <code class="xref py py-obj docutils literal notranslate"><span class="pre">guess_func</span></code> and the <code class="xref py py-obj docutils literal notranslate"><span class="pre">solver</span></code> to
get the most reliable guess possible at each peaks model
parameters.  The default <code class="xref py py-obj docutils literal notranslate"><span class="pre">baseline_func</span></code> returns ysearch as
ysearch = abs(y - median(y)).  Note that the most important
parameter to guess at during this stage is the x center
position of the peak.  Amplitude is not important, but we
do want to get fairly accurate representations of the
rest of the fit parameters such as width or FWHM.</p>
</dd>
<dt><strong>guess_func</strong><span class="classifier">function</span></dt><dd><p>A function of the form:</p>
<blockquote>
<div><p>(x0, y0) = guess_func(x, y_modified)</p>
</div></blockquote>
<p>(x0, y0) is the peak (x_center, y_amplitude) of
the most prominent peak in the data after <code class="xref py py-obj docutils literal notranslate"><span class="pre">baseline_func</span></code> has been
applied.  These results are used to initialize peak parameters
during the search phase.  The default function returns the
(x, y) coordinate of the datum that satisfies
y0 = max(abs(y - median(y))).</p>
</dd>
<dt><strong>optional_func</strong><span class="classifier">function, optional</span></dt><dd><p>An optional function applied to the data prior to the final
fit.  If fitting a background, then no attempt should be made to
remove the background unless it is being accounted for in
some way.  If you are not fitting a background then feel free
to go to town on removing said background.  Preserve whatever
properties of the peak you wish to have appear in the output
results.  Good choices may involve filtering the data.  The
default is to do nothing and fit the final model on the original
data.</p>
</dd>
<dt><strong>fitter_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Additional keywords to pass into the solver during initialization.</p>
</dd>
<dt><strong>fitopts</strong><span class="classifier">dict, optional</span></dt><dd><p>Optional keywords to pass into solver at runtime.</p>
</dd>
<dt><strong>search_kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Additional keyword arguments to supply during model instantiation
during the initial search stage (peak * optional(box)).
Note that the model parameter names are suffixed with “_0” and
box parameter names are suffixed with “_1”, but only if a box
is being applied.  So for example, to
say that you want parameter “p” of the model to remain fixed:</p>
<blockquote>
<div><p>kwargs = {“fixed”: {“p_0”: True}}</p>
</div></blockquote>
<p>As another example, to set parameter “a” of the box equal to
parameter “b” of the model:</p>
<blockquote>
<div><p>kwargs = {“tied”: {“b_1”: lamba x: getattr(x, “a_0”)}}</p>
</div></blockquote>
<p>There are lots of other things you could do here, and I’ve tried
to include as many hooks as possible.  You don’t even need to
treat this thing as a box function.  It could be any kind of
filtering function etc. and you could use kwargs to supply it
with the necessary parameters or behaviours as you wish.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict, optional</span></dt><dd><p>Additional keyword arguments to supply during model instantation
during the final model refinement stage.  Exactly the same type
of thing as <code class="xref py py-obj docutils literal notranslate"><span class="pre">search_kwargs</span></code>.  However, the following suffix
rules apply for parallel fitting (default):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>If fitting only a single peak and no background, do not
suffix any parameters.  “amplitude” remains “amplitude”.</p></li>
<li><p>If fitting multiple peaks, begin suffixing at _0 for the
first peak upto _(npeaks-1) for the last.  i.e. the
amplitude of the 5th peak should be referred to as
“amplitude_4”.</p></li>
<li><p>If fitting a single peak with a background then peak
parameters should be suffixed with “_0” and background
parameters with “_1”.</p></li>
<li><p>If fitting multiple peaks with a single background then
peak parameters should be suffixed according to step 2,
while background parameters should be suffixed with
_(npeaks).  i.e. if there were 5 peaks, the background
“intercept” for a linear background fit should be
referred to as “intercept_5”.</p></li>
</ol>
</div></blockquote>
<p>and for serial fitting:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>If fitting a single peak with no background, do no
suffix any parameters.  “amplitude” remains “amplitude”.</p></li>
<li><p>If fitting one or more peaks with a background then
there is no distinction available between peaks.  Each
peak parameter rule must be applied to all peaks.  For
example, setting {‘bounds’: {‘amplitude_0’: (0, 5)} will
limit the amplitude of all peaks to within the range
0-&gt;5.  The background parameters are suffixed with “_1”.</p></li>
</ol>
</div></blockquote>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>model</strong><span class="classifier">astropy.modeling.Fittable1DModel instance</span></dt><dd><p>The final fitted model.  If more than one peak or a background was
fitted for, then the returned model will be a compound model.
All peaks are located in model[:npeaks].  If a background was
included it can be found at model[npeaks].  If a single peak and
no background was fitted, then an instance of the peak_class will
be returned containing the fit parameters.  No indexing will be
possible.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create compound peaks on a sloped background
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from astropy.modeling import models
&gt;&gt;&gt; from sofia_redux.toolkit.fitting.fitpeaks1d import fitpeaks1d
&gt;&gt;&gt; x = np.linspace(0, 10, 1001)
&gt;&gt;&gt; model1 = models.Gaussian1D(amplitude=3, mean=5, stddev=0.5)
&gt;&gt;&gt; model2 = models.Gaussian1D(amplitude=4, mean=4, stddev=0.2)
&gt;&gt;&gt; y = model1(x) + model2(x) + 0.05 * x + 100
&gt;&gt;&gt; rand = np.random.RandomState(42)
&gt;&gt;&gt; y += rand.normal(0, 0.01, y.size)
&gt;&gt;&gt; fit = fitpeaks1d(x, y, background_class=models.Linear1D,
…                  npeaks=2, min_width=0.1)
&gt;&gt;&gt; rmse = np.sqrt(np.mean(fit.fit_info[‘fvec’] ** 2))
&gt;&gt;&gt; assert np.allclose(fit[0].parameters, [3, 5, 0.5], atol=0.02)  # peak 1
&gt;&gt;&gt; assert np.allclose(fit[1].parameters, [4, 4, 0.2], atol=0.02)  # peak 2
&gt;&gt;&gt; assert np.allclose(fit[2].parameters, [0.1, 100], atol=0.2)  # bg
&gt;&gt;&gt; assert np.isclose(rmse, 0.01, rtol=1)  # residuals</p>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">fitpeaks1d</a><ul>
<li><a class="reference internal" href="#sofia_redux.toolkit.fitting.fitpeaks1d.fitpeaks1d"><code class="docutils literal notranslate"><span class="pre">fitpeaks1d()</span></code></a></li>
</ul>
</li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right">
    <a href="../_sources/api/sofia_redux.toolkit.fitting.fitpeaks1d.fitpeaks1d.rst.txt"
       rel="nofollow">Page Source</a> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.2.6. &nbsp;
    Last built 05 Feb 2024. <br/>
  </p>
</footer>
  </body>
</html>