<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.toolkit.image.coadd &#8212; sofia_redux v1.3.4.dev38+g92ea2f4</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    
    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../../../_static/documentation_options.js?v=6aa39468"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://irsa.ipac.caltech.edu/Missions/sofia.html"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">sofia_redux v1.3.4.dev38+g92ea2f4</a>
	 &#187;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.toolkit.image.coadd</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

from astropy import log
from astropy.wcs import WCS
import numpy as np
import psutil

from sofia_redux.toolkit.image.combine import combine_images
from sofia_redux.toolkit.utilities.fits import hdinsert
from sofia_redux.toolkit.utilities.func import stack
from sofia_redux.toolkit.resampling.resample import Resample
from sofia_redux.toolkit.image.warp import warp_image

__all__ = [&#39;coadd&#39;]


def _target_xy(header, outwcs):
    &quot;&quot;&quot;
    Retrieve target x, y coordinates.

    Parameters
    ----------
    header : astropy.io.fits.Header
        Header to retrieve target RA, Dec from (TGTRA, TGTDEC).
    outwcs : astropy.wcs.WCS
        WCS to transform into

    Returns
    -------
    x, y : float, float
        Target x and y position in provided WCS.
    &quot;&quot;&quot;
    tgt_x, tgt_y = None, None
    tgt_ra = header.get(&#39;TGTRA&#39;, None)
    tgt_dec = header.get(&#39;TGTDEC&#39;, None)
    if tgt_ra is not None and tgt_dec is not None \
            and not np.allclose([tgt_ra, tgt_dec], 0):
        # convert from hours to degrees
        tgt_ra *= 15.0
        if outwcs.wcs.naxis == 2:
            tgt_x, tgt_y = \
                outwcs.wcs_world2pix(tgt_ra, tgt_dec, 0)
        else:
            tgt_w, tgt_y, tgt_x = \
                outwcs.wcs_world2pix(0, tgt_dec, tgt_ra, 0)
    return tgt_x, tgt_y


<div class="viewcode-block" id="coadd">
<a class="viewcode-back" href="../../../../api/sofia_redux.toolkit.image.coadd.coadd.html#sofia_redux.toolkit.image.coadd.coadd">[docs]</a>
def coadd(hdr_list, data_list, var_list, exp_list,
          method=&#39;mean&#39;, weighted=True, robust=True, sigma=8.0,
          maxiters=5, spectral=False, cube=False, wcskey=&#39; &#39;,
          rotate=True, fit_order=2, window=7.0, smoothing=2.0,
          adaptive_algorithm=None, edge_threshold=0.7,
          reference=&#39;first&#39;):
    &quot;&quot;&quot;
    Coadd total intensity or spectral images.

    The WCS is used to transform images into a common coordinate
    system.  By default, the reference field is the WCS for the first
    data set provided.  Optionally, the reference may be corrected
    for target position motion, as for a non-sidereal target.

    For coadd methods &#39;mean&#39; or &#39;median&#39;, each image is interpolated into
    the reference frame, then all images are combined using the chosen
    statistic.  Note that this method may be memory-intensive for large
    fields.  The coadd method &#39;resample&#39; uses locally weighted polynomial
    surface fits to resample data onto the output grid
    (see `sofia_redux.toolkit.resampling` for more information).  Exposure
    maps are always generated by interpolating and summing individual maps.

    The output may be either a 2D image, for either spectral or imaging
    data, or a 3D spectral cube (cube = True).  If cube is set, then the
    method is always &#39;resample&#39;.

    Parameters
    ----------
    hdr_list : list of astropy.io.fits.Header
        List of headers associated with the data to combine.
        The first header in the list is used as the reference.
    data_list : list of numpy.ndarray of float
        List of flux arrays to combine.
    var_list : list of numpy.ndarray of float
        List of variance arrays associated with flux arrays.
    exp_list : list of numpy.ndarray of float
        List of exposure time maps associated with the flux arrays.
    method : {&#39;mean&#39;, &#39;median&#39;, &#39;resample&#39;}, optional
        Method for combining data into the output map.  For &#39;mean&#39; or
        &#39;median&#39;, data is interpolated into the output grid, then
        combined with the selected statistic.  For &#39;resample&#39;, data
        are sampled onto the output grid with locally weighted polynomial
        fits.
    weighted : bool, optional
        If set, input flux values will be weighted by the variance values,
        for &#39;mean&#39; or &#39;resample&#39; methosds.
    robust : bool, optional
        If set, input flux values will be sigma-clipped before combining,
        for &#39;mean&#39; or &#39;median&#39; methods.
    sigma : float, optional
        The sigma value to use for clipping if the `robust` option is set.
    maxiters : int, optional
        Maximum number of sigma-clipping iterations to use if the
        `robust` option is set.
    spectral : bool, optional
        If not set, any dimensions higher than 2 in the input WCS will
        be ignored. This is required for compatibility with old-style
        FORCAST imaging data (pipeline version &lt; 2.0).
    cube : bool, optional
        If set, spectral data is assembled into a 3D cube (nw, ny, nx)
        instead of a 2D spectral image (nw, ny).
    wcskey : str, optional
        Indicates the WCS to use for assembling data.  If &#39; &#39;, the primary
        WCS is used.  For spectral data, the alternate WCS with key &#39;A&#39;
        is expected.
    rotate : bool, optional
        If set, data is rotated to set North up and East left, in RA/Dec
        coordinates.  This option is not recommended for 2D spectral images.
    fit_order : int, optional
        The polynomial fit order to use with the &#39;resample&#39; method.
    window : float, optional
        The local fitting window (in pixels) to use  with the &#39;resample&#39;
        method.
    smoothing : float, optional
        The Gaussian smoothing radius (in pixels) to use  with the &#39;resample&#39;
        method.
    adaptive_algorithm : {&#39;scaled&#39;, &#39;shaped&#39;, None}, optional
        Algorithm for adaptive smoothing kernel.  If scaled, only the
        size is allowed to vary.  If shaped, the kernel shape and
        rotation may also vary.
    edge_threshold : float, optional
        Used to determine how much of the image edges should be masked,
        Specified as a fraction of the fit window; lower values clip more
        pixels.
    reference : {&#39;first&#39;, &#39;target&#39;}, optional
        If set to &#39;target&#39;, the output coordinates for each input file
        will be corrected for target motion, as recorded in the TGTRA
        and TGTDEC keywords. This is necessary to correct for the motion
        of non-sidereal targets.  If TGTRA/DEC are not found, no correction
        will be made.

    Returns
    -------
    header : astropy.io.fits.Header
        The output header with appropriate WCS.
    flux : numpy.ndarray
        The output flux image or cube.
    variance : numpy.ndarray
        The output variance image or cube.
    expmap : numpy.ndarray
        The exposure map associated with the flux. This array
        will always be 2D, even for cube outputs.
    &quot;&quot;&quot;

    # cube is only supported for spectral data
    if cube:
        spectral = True

    # reference all data to the first file
    out_header = hdr_list[0].copy()

    # set reference angle to zero if it isn&#39;t already
    key = wcskey.strip().upper()
    if rotate:
        for wkey in [f&#39;CROTA2{key}&#39;,
                     f&#39;PC1_1{key}&#39;, f&#39;PC1_2{key}&#39;,
                     f&#39;PC2_1{key}&#39;,
                     f&#39;PC2_2{key}&#39;, f&#39;PC2_3{key}&#39;,
                     f&#39;PC3_2{key}&#39;, f&#39;PC3_3{key}&#39;]:
            if wkey in out_header:
                if wkey == f&#39;CROTA2{key}&#39;:
                    out_header[wkey] = 0.0
                else:
                    del out_header[wkey]

        # swap RA to east-left if needed
        ra = f&#39;CDELT1{key}&#39;
        if not cube and ra in out_header and out_header[ra] &gt; 0:
            out_header[ra] *= -1

    # turn down logging to avoid FITS warning for 3D coord sys
    olevel = log.level
    log.setLevel(&#39;ERROR&#39;)
    if not spectral:
        outwcs = WCS(out_header, key=wcskey, naxis=2)
    else:
        outwcs = WCS(out_header, key=wcskey)
    log.setLevel(olevel)

    wcs_dim = outwcs.wcs.naxis
    if cube and wcs_dim &lt; 3:
        msg = &#39;WCS is not 3D. Cannot make cube.&#39;
        log.error(msg)
        raise ValueError(msg)

    if cube:
        # expectation is that 3D coord was in a secondary WCS --
        # we don&#39;t handle it if not
        if key == &#39;&#39;:
            log.error(&#39;Unexpected input WCS condition. &#39;
                      &#39;Cannot fix output header.&#39;)
            raise ValueError

        method = &#39;resample&#39;
        if &#39;SLTW_PIX&#39; not in out_header:
            log.warning(&#39;Slit width not in header; output flux &#39;
                        &#39;may not be conserved.&#39;)
        float_slitw = out_header.get(&#39;SLTW_PIX&#39;, 1.0)
        slit_width = int(np.round(float_slitw))
    else:
        float_slitw = 1.0
        slit_width = 1

    # if referencing to a target RA/Dec (e.g. for nonsidereal targets),
    # get the target position in reference x, y coordinates
    tgt_x, tgt_y = None, None
    if reference == &#39;target&#39;:
        tgt_x, tgt_y = _target_xy(out_header, outwcs)
        if None in (tgt_x, tgt_y):
            msg = &#39;Missing TGTRA or TGTDEC; cannot reference to target.&#39;
            log.warning(msg)

    out_coord_x = []
    out_coord_y = []
    out_coord_w = []
    flxvals = []
    errvals = []
    expvals = []
    corners = []
    for (hdr, flux, var, exp) in zip(hdr_list, data_list, var_list, exp_list):
        # input wcs
        if not spectral:
            inwcs = WCS(hdr, key=wcskey, naxis=2)
        else:
            inwcs = WCS(hdr, key=wcskey)

        # assemble flux, error, and exposure map values
        ny, nx = flux.shape
        err = np.sqrt(var)
        good = ~np.isnan(flux) &amp; ~np.isnan(err)
        if not np.any(good):
            log.warning(f&quot;No good data in &quot;
                        f&quot;{hdr.get(&#39;FILENAME&#39;, &#39;UNKNOWN&#39;)}; skipping.&quot;)
            continue
        if method == &#39;resample&#39;:
            flxvals.append(flux[good])
            errvals.append(err[good])
        else:
            flxvals.append(flux)
            errvals.append(err)
        if cube:
            # exposure value is at one wavelength only, with
            # slit width size, plus two zero columns for padding
            expval = exp[:, 0:slit_width + 2]
            expval[:, 0] = 0
            expval[:, -1] = 0
            expvals.append(expval)
        else:
            expvals.append(exp)

        # index values for resampling
        yin, xin = np.meshgrid(np.arange(ny), np.arange(nx), indexing=&#39;ij&#39;)
        yin = yin[good]
        xin = xin[good]
        xamin, xamax = np.argmin(xin), np.argmax(xin)
        yamin, yamax = np.argmin(yin), np.argmax(yin)

        # corner values for interpolation
        if cube:
            in_corner = [[xin[xamin], xin[xamin],
                          xin[xamax], xin[xamax]],
                         [yin[yamin], yin[yamax],
                          yin[yamin], yin[yamax]],
                         [-slit_width / 2 + 0.5, -slit_width / 2 + 0.5,
                          slit_width / 2 - 0.5, slit_width / 2 - 0.5]]
        else:
            in_corner = [[xin[xamin], xin[xamin],
                          xin[xamax], xin[xamax]],
                         [yin[yamin], yin[yamax],
                          yin[yamin], yin[yamax]]]

        # transform all coords to reference WCS
        if wcs_dim == 2:
            wxy = inwcs.wcs_pix2world(xin, yin, 0)
            oxy = outwcs.wcs_world2pix(*wxy, 0)
            cxy = inwcs.wcs_pix2world(*in_corner, 0)
            out_corner = outwcs.wcs_world2pix(*cxy, 0)
        else:
            wxy = inwcs.wcs_pix2world(xin, yin, 0, 0)
            oxy = outwcs.wcs_world2pix(*wxy, 0)
            if cube:
                cxy = inwcs.wcs_pix2world(*in_corner, 0)
                out_corner = outwcs.wcs_world2pix(*cxy, 0)
                # ra, dec corners
                in_corner = [in_corner[2], in_corner[1]]
                # correct for slit width offset in not-yet
                # existant 3rd dimension
                out_corner = np.array([out_corner[2] - slit_width / 2,
                                       out_corner[1]])
            else:
                cxy = inwcs.wcs_pix2world(*in_corner, 0, 0)
                out_corner = outwcs.wcs_world2pix(*cxy, 0)[0:2]

        # correct all coordinates for target movement
        x_off, y_off = 0., 0.
        if None not in [tgt_x, tgt_y]:
            upd_x, upd_y = _target_xy(hdr, outwcs)
            if None in [upd_x, upd_y]:
                log.warning(f&quot;Missing target RA/Dec in file &quot;
                            f&quot;{hdr.get(&#39;FILENAME&#39;, &#39;UNKNOWN&#39;)}.&quot;)
            else:
                x_off = tgt_x - upd_x
                y_off = tgt_y - upd_y

        if cube and wcs_dim == 3:
            # assuming crval1=wavelength, crval2=dec, crval3=ra
            out_coord_w.append(oxy[0])
            out_coord_y.append(oxy[1] + y_off)
            out_coord_x.append(oxy[2] + x_off)
        else:
            out_coord_x.append(oxy[0] + x_off)
            out_coord_y.append(oxy[1] + y_off)

        out_corner[0] += x_off
        out_corner[1] += y_off
        corners.append((in_corner, out_corner))

    # output grid shape
    stk_coord_x = np.hstack(out_coord_x)
    minx, maxx = np.min(stk_coord_x), np.max(stk_coord_x)
    stk_coord_y = np.hstack(out_coord_y)
    miny, maxy = np.min(stk_coord_y), np.max(stk_coord_y)

    # shift coordinates to new grid
    stk_coord_x -= minx
    stk_coord_y -= miny

    # stack coordinates for output grid
    if cube:
        stk_coord_w = np.hstack(out_coord_w)
        minw, maxw = np.min(stk_coord_w), np.max(stk_coord_w)
        out_shape = (int(np.ceil(maxw) - np.floor(minw) + 1),
                     int(np.ceil(maxy) - np.floor(miny) + 1),
                     int(np.ceil(maxx) - np.floor(minx)) + 1)
        stk_coord_w -= minw
        coordinates = stack(stk_coord_x, stk_coord_y, stk_coord_w)

        xout = np.arange(out_shape[2], dtype=np.float64)
        yout = np.arange(out_shape[1], dtype=np.float64)
        wout = np.arange(out_shape[0], dtype=np.float64)
        grid = xout, yout, wout

        # fix header reference pixel for new min value in w and x
        out_header[&#39;CRPIX1&#39; + key] -= minw
        out_header[&#39;CRPIX2&#39; + key] -= miny
        out_header[&#39;CRPIX3&#39; + key] -= minx
    else:
        out_shape = (int(np.ceil(maxy) - np.floor(miny) + 1),
                     int(np.ceil(maxx) - np.floor(minx)) + 1)

        coordinates = stack(stk_coord_x, stk_coord_y)

        xout = np.arange(out_shape[1], dtype=np.float64)
        yout = np.arange(out_shape[0], dtype=np.float64)
        grid = xout, yout

        # fix header reference pixel
        out_header[&#39;CRPIX1&#39; + key] -= minx
        out_header[&#39;CRPIX2&#39; + key] -= miny

        # also fix primary coordinates for 2D spectrum
        if key != &#39;&#39; and wcs_dim &gt; 2:
            out_header[&#39;CRPIX1&#39;] -= minx
            out_header[&#39;CRPIX2&#39;] -= miny

    log.info(&#39;Output shape: {}&#39;.format(out_shape))

    # use local polynomial fits to resample and coadd data
    if method == &#39;resample&#39;:
        flxvals = np.hstack(flxvals)
        errvals = np.hstack(errvals)

        if cube:
            edge_threshold = (edge_threshold, edge_threshold, 0)
            window = (window, window, 2.0)
            smoothing = (smoothing, smoothing, 1.0)
            if adaptive_algorithm in [&#39;scaled&#39;, &#39;shaped&#39;]:
                adaptive_threshold = (1.0, 1.0, 0.0)
            else:
                adaptive_threshold = None
                adaptive_algorithm = None
        else:
            if adaptive_algorithm in [&#39;scaled&#39;, &#39;shaped&#39;]:
                adaptive_threshold = 1.0
            else:
                adaptive_threshold = None
                adaptive_algorithm = None

        max_cores = psutil.cpu_count() - 1
        if max_cores &lt; 2:  # pragma: no cover
            max_cores = None

        log.info(&#39;Setting up output grid.&#39;)
        resampler = Resample(
            coordinates, flxvals, error=errvals,
            window=window, order=fit_order, fix_order=True)

        log.info(&#39;Resampling flux data.&#39;)
        flux, std = resampler(
            *grid, smoothing=smoothing, edge_threshold=edge_threshold,
            adaptive_threshold=adaptive_threshold,
            adaptive_algorithm=adaptive_algorithm,
            edge_algorithm=&#39;distribution&#39;, get_error=True,
            error_weighting=weighted, jobs=max_cores)
        var = std**2

        log.info(&#39;Interpolating and summing exposure maps.&#39;)
        if cube:
            expmap = np.zeros(out_shape[1:], dtype=float)
        else:
            expmap = np.zeros(out_shape, dtype=float)
        for i, expval in enumerate(expvals):
            inx, iny = corners[i][0]
            outx, outy = corners[i][1]
            outx -= minx
            outy -= miny
            exp_out = warp_image(
                expval, inx, iny, outx, outy,
                output_shape=expmap.shape, cval=0,
                order=1, interpolation_order=1)
            expmap += exp_out
    else:
        # interpolate corners for approximate warp solution
        log.info(&#39;Interpolating all images.&#39;)

        flx = []
        vr = []
        expmap = np.zeros(out_shape)
        for i, (flxval, errval, expval) in \
                enumerate(zip(flxvals, errvals, expvals)):
            inx, iny = corners[i][0]
            outx, outy = corners[i][1]
            outx -= minx
            outy -= miny

            # flux image
            flx.append(
                warp_image(flxval, inx, iny, outx, outy,
                           output_shape=out_shape, cval=np.nan,
                           order=1, interpolation_order=1))

            # var image
            vr.append(
                warp_image(errval**2, inx, iny, outx, outy,
                           output_shape=out_shape, cval=np.nan,
                           order=1, interpolation_order=0))

            # exposure map image
            exp_out = warp_image(
                expval, inx, iny, outx, outy,
                output_shape=out_shape, cval=0,
                order=1, interpolation_order=0)
            expmap += exp_out

        if len(flx) &gt; 1:
            log.info(&#39;{}-combining images.&#39;.format(method.title()))
            flux, var = combine_images(
                flx, variance=vr, method=method, weighted=weighted,
                robust=robust, sigma=sigma, maxiters=maxiters)
        else:
            flux, var = flx[0], vr[0]

    if cube:
        # reconstruct as primary wcs
        key = wcskey.strip().upper()
        wcs_key_set = [&#39;CTYPE1&#39;, &#39;CTYPE2&#39;, &#39;CUNIT1&#39;, &#39;CUNIT2&#39;,
                       &#39;CRPIX1&#39;, &#39;CRPIX2&#39;, &#39;CRVAL1&#39;, &#39;CRVAL2&#39;,
                       &#39;CDELT1&#39;, &#39;CDELT2&#39;, &#39;CROTA2&#39;, &#39;SPECSYS&#39;,
                       f&#39;CTYPE1{key}&#39;, f&#39;CTYPE2{key}&#39;, f&#39;CTYPE3{key}&#39;,
                       f&#39;CUNIT1{key}&#39;, f&#39;CUNIT2{key}&#39;, f&#39;CUNIT3{key}&#39;,
                       f&#39;CRPIX1{key}&#39;, f&#39;CRPIX2{key}&#39;, f&#39;CRPIX3{key}&#39;,
                       f&#39;CRVAL1{key}&#39;, f&#39;CRVAL2{key}&#39;, f&#39;CRVAL3{key}&#39;,
                       f&#39;CDELT1{key}&#39;, f&#39;CDELT2{key}&#39;, f&#39;CDELT3{key}&#39;,
                       f&#39;RADESYS{key}&#39;, f&#39;EQUINOX{key}&#39;, f&#39;SPECSYS{key}&#39;]
        tmp = out_header.copy()
        for wkey in wcs_key_set:
            if wkey in out_header:
                del out_header[wkey]
            if wkey.endswith(key) and wkey in tmp:
                # swap coords 1 and 3 (to make it wave, RA, Dec)
                new_key = wkey[:-1].replace(&#39;3&#39;, &#39;9999&#39;)
                new_key = new_key.replace(&#39;1&#39;, &#39;3&#39;).replace(&#39;9999&#39;, &#39;1&#39;)
                hdinsert(out_header, new_key, tmp[wkey], tmp.comments[wkey])

    # fix source position estimate too
    if &#39;SRCPOSX&#39; in out_header and &#39;SRCPOSY&#39; in out_header:
        coord = ([out_header[&#39;SRCPOSX&#39;]],
                 [out_header[&#39;SRCPOSY&#39;]])
        first_wcs = WCS(hdr_list[0], naxis=2)
        out_wcs = WCS(out_header, naxis=2)
        sxy = first_wcs.wcs_pix2world(*coord, 0)
        new_xy = out_wcs.wcs_world2pix(*sxy, 0)
        out_header[&#39;SRCPOSX&#39;] = new_xy[0][0]
        out_header[&#39;SRCPOSY&#39;] = new_xy[1][0]

    if cube:
        # correct flux for pixel size change
        # before: pixel x slit width in pixels
        # after: pixel x pixel
        flux /= float_slitw
        var /= float_slitw**2

    return out_header, flux, var, expmap</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2024, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.2.6. &nbsp;
    Last built 05 Feb 2024. <br/>
  </p>
</footer>
  </body>
</html>